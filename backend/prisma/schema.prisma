generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                          String    @id @default(uuid())
  name                        String
  email                       String    @unique
  password                    String?
  googleId                    String?
  facebookId                  String?
  ethnicity                   String?
  countryOfOrigin             String?
  dateOfBirth                 String?
  gender                      Gender?   @default(Male)
  role                        UserRole  @default(REGULAR)
  isProfileCompleted          Boolean   @default(false)
  isEmailVerified             Boolean   @default(false)
  isBanned                    Boolean   @default(false)
  verificationToken           String?
  verificationTokenExpiration DateTime?
  resetPasswordToken          String?
  resetPasswordExpiration     DateTime?
  activeMatch                 Match?    @relation(name: "activeMatch")
  pictures                    Picture[]
  votes                       Vote[]    @relation(name: "voter")
  reports                     Report[]
  createdAt                   DateTime  @default(now())
  updatedAt                   DateTime  @updatedAt
}

enum UserRole {
  ADMIN
  REGULAR
}

enum Gender {
  Male
  Female
}

model Picture {
  id              String   @id @default(uuid())
  filepath        String
  rating          Float
  ratingDeviation Float
  volatility      Float
  numVotes        Int      @default(0)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String
  matches         Match[]
  votesWinner     Vote[]   @relation(name: "winnerPicture")
  reports         Report[]
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Vote {
  id              String   @id @default(uuid())
  winnerPicture   Picture  @relation(fields: [winnerPictureId], references: [id], onDelete: Cascade, name: "winnerPicture")
  winnerPictureId String
  voter           User     @relation(fields: [voterId], references: [id], onDelete: Cascade, name: "voter")
  voterId         String
  match           Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  matchId         String   @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Match {
  id           String    @id @default(uuid())
  activeUser   User?     @relation(name: "activeMatch", fields: [activeUserId], references: [id], onDelete: Cascade)
  activeUserId String?   @unique
  pictures     Picture[]
  votes        Vote?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

model Report {
  id              String   @id @default(uuid())
  picture         Picture  @relation(fields: [pictureId], references: [id], onDelete: Cascade)
  userReporting   User     @relation(fields: [userReportingId], references: [id], onDelete: Cascade)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  pictureId       String
  userReportingId String
}

model BannedUser {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
